\c one_db
SET search_path TO api_0_0_1, base_0_0_1, public;
-- POST
-- GET
\c [[data-database-name]]



SET search_path TO [[data-schema]], base_0_0_1, public;



-- GET



CREATE OR REPLACE FUNCTION [[data-schema]].[[data-name]](token TEXT, form JSON, options JSON) RETURNS JSONB AS $$

    Declare _form JSONB;

    Declare result JSONB;

BEGIN

          -- [Function: User GET]

          -- [Description: Find the values of a user chelate]

          -- [Parameters: token TEXT,form JSON,options JSON]



          set role api_guest;



          -- [A. Validate Token]

          result := base_0_0_1.validate_token(token) ;

          if result is NULL then

            -- [A.1 Fail 403 When token is invalid]

            RESET ROLE;

            return format('{"status":"403","msg":"Forbidden","extra":"Invalid token","user":"%s"}',CURRENT_USER)::JSONB;

          end if;



          -- [B. Verify Parameters]

          -- eg if not(result ->> 'scope' = 'api_admin') and not(result ->> 'scope' = 'api_guest') then

          if [[data-methods-GET-scopeVerificationCondition]] then

              RESET ROLE;

              -- [B.1 Fail 401 when unexpected scope is detected]

              return '{"status":"401","msg":"Unauthorized"}'::JSONB;

          end if;



          if form is NULL then

              -- [B.2 Fail 400 when form is NULL]

              RESET ROLE;

              return '{"status":"400","msg":"Bad Request"}'::JSONB;

          end if;



          _form := form::JSONB;



          -- eg. if not(_form ? 'username') then"

          if [[data-methods-GET-requiredFieldCondition]] then

              -- [B.3 Fail 400 when form is missing a required field]

              RESET ROLE;

              return '{"status":"400","msg":"Bad Request"}'::JSONB;

          end if;



          -- [C. Assemble Chelate Data]



          [[data-methods-GET-customRoleCode]]



          -- [D. Query Chelate]

          result := base_0_0_1.query(_form);

          RESET ROLE;

          -- [Return {status,msg,selection}]

          return result;

END;

$$ LANGUAGE plpgsql;

-- GET

-- e.g., grant EXECUTE on FUNCTION

[[data-methods-GET-grant]]

-- DELETE
\c [[data-database-name]]



SET search_path TO [[data-schema]], base_0_0_1, public;



-- DELETE



CREATE OR REPLACE FUNCTION [[data-schema]].[[data-name]](token TEXT,pk TEXT) RETURNS JSONB AS $$

    Declare result JSONB;

    Declare _form JSONB := '{}'::JSONB;

BEGIN

          -- [Function: [[data-name]] DELETE]

          -- [Description: remove item by primary key ]

          -- [Parameters: token TEXT,pk TEXT]



          set role api_guest;



          -- [A. Validate Token]

          result := base_0_0_1.validate_token(token) ;

          if result is NULL then

            -- [A.1 Fail 403 When token is invalid]

            RESET ROLE;

            return format('{"status":"403","msg":"Forbidden","extra":"Invalid token","user":"%s"}',CURRENT_USER)::JSONB;

          end if;



          -- [B. Validate Parameters]

          -- eg if not(result ->> 'scope' = 'api_admin') and not(result ->> 'scope' = 'api_guest') then

          if [[data-methods-DELETE-scopeVerificationCondition]] then

              -- [B.1 Fail 401 when unexpected token scope is detected]

              RESET ROLE;

              return '{"status":"401","msg":"Unauthorized"}'::JSONB;

          end if;



          if pk is NULL then

              -- [B.2 Fail 400 when pk is NULL]

              RESET ROLE;

              return '{"status":"400","msg":"Bad Request"}'::JSONB;

          end if;



          -- [C. Assemble Chelate Data]



          [[data-methods-DELETE-customRoleCode]]



          -- [D. Delete Chelate]

          result := base_0_0_1.delete(_form);

          RESET ROLE;



          -- [Return {status,msg,deletion}]

          return result;

END;

$$ LANGUAGE plpgsql;

-- DELETE

-- e.g., grant EXECUTE on FUNCTION

[[data-methods-DELETE-grant]]

-- PUT
\c [[data-database-name]]



SET search_path TO [[data-schema]], base_0_0_1, public;



-- PUT



CREATE OR REPLACE FUNCTION [[data-schema]].[[data-name]](token TEXT,pk TEXT,form JSON) RETURNS JSONB AS $$

    Declare _chelate JSONB := '{}'::JSONB;

    Declare _criteria JSONB := '{}'::JSONB;

    Declare _form JSONB := '{}'::JSONB;

    Declare result JSONB;



BEGIN

          -- [Function: User PUT]

          -- [Description: Change form keys. Pk, sk, tk will change when related form key change]

          -- [Parameters: token TEXT,pk JSON, form JSON]



          set role api_guest;



          -- [A. Validate token]

          result := base_0_0_1.validate_token(token) ;

          if result is NULL then

            -- [A.1 Fail 403 When token is invalid]

            RESET ROLE;

            return format('{"status":"403","msg":"Forbidden","extra":"Invalid token","user":"%s"}',CURRENT_USER)::JSONB;

          end if;



          -- [B. Verify Parameters]

          -- eg if not(result ->> 'scope' = 'api_admin') and not(result ->> 'scope' = 'api_guest') then

          if [[data-methods-PUT-scopeVerificationCondition]] then

              -- [B.1 Fail 401 when unexpected scope is detected]

              RESET ROLE;

              return '{"status":"401","msg":"Unauthorized"}'::JSONB;

          end if;



          if pk is NULL then

              -- [B.2 Fail 400 when pk is NULL]

              RESET ROLE;

              return '{"status":"400","msg":"Bad Request"}'::JSONB;

          end if;



          if form is NULL then

              -- [B.3 Fail 400 when form is NULL]

              RESET ROLE;

              return '{"status":"400","msg":"Bad Request"}'::JSONB;

          end if;



          _form := form::JSONB;



          -- [C. Assemble Chelate Data]



          -- [C.1 Password hash]

          [[data-methods-PUT-passwordHashCode]]



          -- [C.2 User specific code]

          [[data-methods-PUT-customRoleCode]]



          -- [D. Update Chelate]

          result := base_0_0_1.update(_chelate);

          RESET ROLE;



          -- [Return {status,msg,updation}]

          return result;

END;

$$ LANGUAGE plpgsql;

-- PUT

-- e.g., grant EXECUTE on FUNCTION

[[data-methods-PUT-grant]]
